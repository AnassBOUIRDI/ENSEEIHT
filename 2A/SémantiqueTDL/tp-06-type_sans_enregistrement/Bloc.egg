  ----------------------------------------------- -*- text -*-
-- Langage BLOC : Bloc, Instruction et Expression façon C/Java/...
-- Sémantique : Construction de l'arbre abstrait et gestion de la
--                      table des symboles. 
-----------------------------------------------'
option auto= true;
option version = 0.0.1 ;
option k=1;


inh gauche	 :  Expression for SuiteCondition, SuiteTerme, SuiteFacteur;
inh factory	 :  BlockFactory for Bloc, Instruction,
    		  	    SuiteConditionnelle, Instructions, Expression, Condition,
			          SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Type, Valeur ;  
inh tds      :  SymbolTable for Bloc, Instruction,SuiteConditionnelle, Instructions, Expression, Condition,
                SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur, Valeur,Type;  
--syn ast    :  Expression for  Programme; 
syn ast      :  Block for Bloc, Programme, SuiteConditionnelle;
syn ast      :  Expression for Expression, Condition, SuiteCondition, Terme, SuiteTerme, Facteur, SuiteFacteur,Valeur ;
syn ast      :  Type for Type ;
syn bin_op   :  BinaryOperator for Additif, Multiplicatif, Comparatif;
syn listInst :  List<Instruction> for Instructions;
syn inst     :  Instruction for Instruction;


space  separateur				       is    "[\n\r\t ]+";
space  commentaire			       is    "\/\/.*\n";
sugar  accolade_ouvrante		   is    "\{";  
sugar  accolade_fermante		   is    "\}";  
sugar  crochet_ouvrant			   is    "\[";  
sugar  crochet_fermant			   is    "\]";  
sugar  parenthese_ouvrante		 is    "\(";
sugar  parenthese_fermante		 is    "\)";
sugar  inferieur				       is    "\<";  
sugar  superieur				       is    "\>";  
sugar  inferieur_egal			     is    "\<=";  
sugar  superieur_egal			     is    "\>=";  
sugar  point					         is    "\.";  
sugar  point_virgule			     is    ";";  
sugar  virgule					       is    ",";
sugar  affectation				     is    "=";
sugar  different               is    "\!=";
sugar  egalite					       is    "==";
sugar  addition				         is    "\+";
sugar  soustraction				     is    "\-";
sugar  ou						           is    "\|\|";  
sugar  multiplication			     is    "\*";
sugar  division				         is    "/";
sugar  modulo					         is    "%";
sugar  negation				         is    "\!";
sugar  et						           is    "&&";  
sugar  vrai					           is    "true";
sugar  faux					           is    "false";
sugar  si						           is    "if";
sugar  sinon					         is    "else";
sugar  afficher					       is    "print";
sugar  tant_que				         is    "while";
sugar  premier					       is    "fst";
sugar  second					         is    "snd";
sugar  type_int				         is    "int";
sugar  type_bool				       is    "bool";
sugar  enregistrement			     is    "struct";
sugar  constante               is    "const";
sugar  typedef                 is    "typedef";
term   entier					         is    "[0-9]+";
term   identificateur			     is    "[a-z][a-zA-Z0-9_]*"; 
term   identificateur_type		 is    "[A-Z][a-zA-Z0-9_]*"; 


-- Remplacer la règle suivante pour pouvoir traiter les instructions

Programme -> identificateur #inh Bloc #ast;
#inh {
do
   Bloc^factory := new BlockFactoryImpl();
   Bloc^tds := null;
end
}
#ast {
do
   Programme^ast := Bloc^ast;
end
}

---------------------------------------------------------------------------

--Programme -> identificateur #inh Expression #ast ;
--#inh {
--do
--   Expression^factory := new BlockFactoryImpl();
--end
--}
--#ast {
--do
--   Programme^ast := Expression^ast;
--end
--}

---------------------------------------------------------------------------

Bloc -> accolade_ouvrante #inh Instructions accolade_fermante #ast;
#inh {
  do
    Instructions^tds := new SymbolTable(Bloc^tds);
  end
}

#ast {
  do
    Bloc^ast := Bloc^factory.createBlock(Instructions^listInst);
  end
}



---------------------------------------------------------------------------

Type -> type_bool #ast ;
#ast {
do
   Type^ast := Type^factory.createBooleanType();  
end
}

---------------------------------------------------------------------------

Type -> type_int  #ast ;
#ast {
do
   Type^ast := Type^factory.createIntegerType(); 
end
}

---------------------------------------------------------------------------

Type -> inferieur Type virgule Type superieur  #ast;
#ast {
do
    Type^ast := Type^factory.createCoupleType(Type1^ast, Type2^ast);
end
}

---------------------------------------------------------------------------

Instructions -> #listInst;
#listInst {
do
    Instructions^listInst := new ArrayList<Instruction>();
end
}

---------------------------------------------------------------------------

Instructions -> Instruction Instructions #listInst;
#listInst {
  do
      Instructions^listInst := new ArrayList<Instruction>(Instructions1^listInst);
      Instructions^listInst.add(Instruction^inst);
  end
}


---------------------------------------------------------------------------

Instruction -> Type identificateur affectation Expression point_virgule #inst;
#inst {
  local
    tmp : VariableDeclaration;
  do
      if ! Instruction^tds.knows(identificateur^txt) then 
          tmp := Instruction^factory.createVariableDeclaration(identificateur^txt, Type^ast, Expression^ast);
          Instruction^inst := tmp;
          Instruction^tds.register(tmp);
      end
  end
}


---------------------------------------------------------------------------
Instruction -> identificateur affectation Expression point_virgule #inst;
#inst {
  local 
      tmp : Declaration;
      varReturned: Optional<Declaration>;
  do
      varReturned := null;
      if Instruction^tds.knows(identificateur^txt) then
            varReturned := Instruction^tds.get(identificateur^txt);
            tmp := varReturned.get();
            match tmp
              with VariableDeclaration then
                  Instruction^inst := Instruction^factory.createAssignment(tmp, Expression^ast);            
      
              with ConstantDeclaration then
                  error(Constant_unexpected,identificateur^txt);
              else 
                  error(Bloc_unexpected_token,identificateur^txt);
            end
      end
  end
}


---------------------------------------------------------------------------

Instruction -> si parenthese_ouvrante Expression parenthese_fermante Bloc SuiteConditionnelle #inst;
#inst {
  do
    if SuiteConditionnelle^ast != null then 
        Instruction^inst := Instruction^factory.createConditional(Expression^ast, Bloc^ast, SuiteConditionnelle^ast);
    else 
        Instruction^inst := Instruction^factory.createConditional(Expression^ast, Bloc^ast);
    end
  end
}


---------------------------------------------------------------------------

SuiteConditionnelle -> #ast;
#ast {
  do
    SuiteConditionnelle^ast := null;
  end
}

---------------------------------------------------------------------------

SuiteConditionnelle -> sinon Bloc #ast;
#ast {
  do
    SuiteConditionnelle^ast := SuiteConditionnelle^factory.createBlock(Bloc^ast);
  end
}

---------------------------------------------------------------------------

Instruction -> tant_que parenthese_ouvrante Expression parenthese_fermante Bloc #inst ;
#inst {
  do
    Instruction^inst := Instruction^factory.createRepetition(Expression^ast, Bloc^ast);
  end
}

---------------------------------------------------------------------------

Instruction -> afficher parenthese_ouvrante Expression parenthese_fermante point_virgule #inst;
#inst {
  do
    Instruction^inst := Instruction^factory.createPrinter(Expression^ast);
  end
}


---------------------------------------------------------------------------

Expression -> Condition #inh SuiteCondition #ast ;
#inh {
do
   SuiteCondition^gauche := Condition^ast ;
end 
}
#ast {
do
    Expression^ast := SuiteCondition^ast;
end 
}

---------------------------------------------------------------------------

SuiteCondition -> Comparatif Condition #ast ;
#ast {
do
	SuiteCondition^ast :=
	SuiteCondition^factory.createBinaryExpression(
	SuiteCondition^gauche,
	Comparatif^bin_op,
	Condition^ast);
end 
}

---------------------------------------------------------------------------

SuiteCondition -> #ast ;
#ast {
do
   SuiteCondition^ast := SuiteCondition^gauche;
end 
}

---------------------------------------------------------------------------

Comparatif -> egalite #texte;
#texte {
do
   Comparatif^bin_op := BinaryOperator.Equals;
end
}

---------------------------------------------------------------------------

Condition -> Terme #ast_inh SuiteTerme #ast_syn ;
#ast_inh {
do 
   SuiteTerme^gauche := Terme^ast; 
end 
}

#ast_syn {
do
   Condition^ast := SuiteTerme^ast; 
end
}

---------------------------------------------------------------------------

SuiteTerme -> Additif Terme #ast_inh SuiteTerme #ast_syn ;  
#ast_inh {
do
   SuiteTerme1^gauche := SuiteTerme^factory.createBinaryExpression(
      SuiteTerme^gauche,  
      Additif^bin_op,  
      Terme^ast);  
end 
}

---------------------------------------------------------------------------

#ast_syn {
do 
   SuiteTerme^ast := SuiteTerme1^ast; 
end 
}

---------------------------------------------------------------------------

SuiteTerme -> #ast ;
#ast {
do
   SuiteTerme^ast := SuiteTerme^gauche;
end
}

---------------------------------------------------------------------------

Additif -> addition #ast;  
#ast { 
do  
   Additif^bin_op := BinaryOperator.Add;  
end  
}
  
---------------------------------------------------------------------------

Terme -> Facteur #ast_inh SuiteFacteur #ast_syn ;
#ast_inh {
do 
   SuiteFacteur^gauche := Facteur^ast; 
end 
}

#ast_syn {
do
   Terme^ast := SuiteFacteur^ast; 
end
}

---------------------------------------------------------------------------

SuiteFacteur -> Multiplicatif Facteur #ast_inh SuiteFacteur #ast_syn ;  
#ast_inh {
do 
   SuiteFacteur1^gauche := SuiteFacteur^factory.createBinaryExpression(
      SuiteFacteur^gauche,  
      Multiplicatif^bin_op,  
      Facteur^ast);  
end 
}

---------------------------------------------------------------------------

#ast_syn {
do 
   SuiteFacteur^ast := SuiteFacteur1^ast; 
end 
}
 
---------------------------------------------------------------------------

SuiteFacteur -> #ast;  
#ast {
do
   SuiteFacteur^ast := SuiteFacteur^gauche;
end
}

---------------------------------------------------------------------------

Multiplicatif -> multiplication #ast; 
#ast {
do 
   Multiplicatif^bin_op := BinaryOperator.Multiply; 
end 
}

---------------------------------------------------------------------------

Facteur -> parenthese_ouvrante Expression parenthese_fermante #ast;  
#ast { 
do  
   Facteur^ast := Expression^ast;  
end  
}
 
---------------------------------------------------------------------------
Facteur -> identificateur #ast ;  
#ast { 
local 
  varReturned : Optional<Declaration>;
  tmp : Declaration;
do  
    varReturned := null;
    if Facteur^tds.knows(identificateur^txt) then
        varReturned := Facteur^tds.get(identificateur^txt);
        tmp := varReturned.get();

        match tmp
          with VariableDeclaration then
              Facteur^ast := Facteur^factory.createVariableUse(tmp);  
          with ConstantDeclaration then
              Facteur^ast := tmp.getValue();
          else
              error(Bloc_unexpected_token,identificateur^txt);
        end
    end

end  
}


---------------------------------------------------------------------------
--
--Facteur -> inferieur Expression virgule Expression superieur #ast ;  
--
--#ast {
--  do
--    Facteur^ast := Facteur^factory.createCouple(Expression^ast, Expression1^ast);
--  end
--}

---------------------------------------------------------------------------
 
Facteur -> premier Facteur #ast ;

#ast {
  do
    Facteur^ast := Facteur^factory.createFirst(Facteur1^ast);
  end
}

---------------------------------------------------------------------------
 
Facteur -> second Facteur #ast;  

#ast {
  do
    Facteur^ast := Facteur^factory.createSecond(Facteur1^ast);
  end
}

---------------------------------------------------------------------------

Instruction -> constante Type identificateur affectation Valeur point_virgule #inst;
#inst {
local
  tmp : ConstantDeclaration; 
  do
    if ! Instruction^tds.knows(identificateur^txt) then 
      tmp := Instruction^factory.createConstantDeclaration(identificateur^txt, Type^ast,Valeur^ast);
      Instruction^inst := tmp;
      Instruction^tds.register(tmp);
    end
  end
}

---------------------------------------------------------------------------

Facteur -> Valeur #ast;
#ast {
do
   Facteur^ast := Valeur^ast;
end
}

---------------------------------------------------------------------------
 
Valeur -> entier #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createIntegerValue(entier^txt); 
end
}

---------------------------------------------------------------------------

Valeur -> vrai #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(true);  
end
}

---------------------------------------------------------------------------

Valeur -> faux #ast;
#ast {
do
    Valeur^ast := Valeur^factory.createBooleanValue(false);  
end
}











---------------------------------------------------------------------------

Comparatif -> different #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Different;   
end  
}

---------------------------------------------------------------------------

Comparatif -> inferieur #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.Lesser;   
end  
}

---------------------------------------------------------------------------

Comparatif -> inferieur_egal #texte;  
#texte {  
do  
   Comparatif^bin_op := BinaryOperator.LesserOrEqual;   
end  
}
  
---------------------------------------------------------------------------

Comparatif -> superieur #texte;  
#texte {   
do  
   Comparatif^bin_op := BinaryOperator.Greater;    
end  
}

---------------------------------------------------------------------------
   
Comparatif -> superieur_egal #texte;  
#texte {   
do  
   Comparatif^bin_op := BinaryOperator.GreaterOrEqual;    
end  
}

---------------------------------------------------------------------------

Additif -> soustraction #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Substract;   
end  
}
   
---------------------------------------------------------------------------

Additif -> ou #ast;  
#ast {  
do  
   Additif^bin_op := BinaryOperator.Or;   
end  
}

---------------------------------------------------------------------------

Multiplicatif -> division #ast; 
#ast { 
do 
   Multiplicatif^bin_op := BinaryOperator.Divide;  
end 
}
 
---------------------------------------------------------------------------

Multiplicatif -> modulo #ast; 
#ast {  
do 
   Multiplicatif^bin_op := BinaryOperator.Modulo;   
end 
}
  
---------------------------------------------------------------------------

Multiplicatif -> et #ast; 
#ast {  
do 
   Multiplicatif^bin_op := BinaryOperator.And;   
end 
}

---------------------------------------------------------------------------

Facteur -> soustraction Facteur #ast ;  
#ast { 
do  
   Facteur^ast := Facteur ^factory.createUnaryExpression(UnaryOperator.Opposite,Facteur1^ast);  
end  
}
 
---------------------------------------------------------------------------

Facteur -> negation Facteur #ast ;  
#ast { 
do  
   Facteur^ast := Facteur ^factory. createUnaryExpression(UnaryOperator.Negate,Facteur1^ast);  
end  
}









---------------------------------------------------------------------------

Instruction -> typedef Type identificateur_type point_virgule #ast ;
#ast {
local 
   v : TypeDeclaration ; 
do 
   if Instruction^tds.contains(identificateur_type^txt) then 
      error(B_00, identificateur_type^txt); 
   else
      v := Instruction^factory.createTypeDeclaration(identificateur_type^txt,Type^ast); 
      Instruction^tds.register(v);
      Instruction^inst := v; 
   end 
end 
} 


---------------------------------------------------------------------------

Type -> identificateur_type #ast ;
#ast {
local
   d : Optional<Declaration>;
   t : Declaration;
do
   -- Si l''identificateur de type est connu
   if Type^tds.knows(identificateur_type^txt) then

      -- Lecture dans la table des symboles
      d := Type^tds.get(identificateur_type^txt);

      -- Si celle-ci a renvoyé un élément
      if (d.isPresent()) then

         -- Accès à cet élément
         t := d.get();
         match t
           -- Si c''est un type, il est renvoyé
           with TypeDeclaration then Type^ast := t.getType();
           -- Sinon une erreur est signalée
           else
              error(BLOC_not_a_type,identificateur_type^txt);
           end

      -- Sinon une erreur est signalée
      else
         error(BLOC_undefined_ident,identificateur_type^txt);
      end

   -- Sinon une erreur est signalée
   else
      error(BLOC_undefined_ident,identificateur_type^txt);
   end
end
}


end